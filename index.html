<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- ビューポートのメタタグを追加 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Noto Sans JP フォントを読み込む -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">

    <title>Fourier Tone Analyzer</title>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif; /* 全体のフォントを Noto Sans JP に設定 */
            color: #595959; /* フォントの色を #595959 に設定 */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
        }
        canvas {
            border: 1px solid #999999; /* 枠線の色を黒より少しグレー寄りに変更 */
            margin-bottom: 20px;
        }
        button {
            margin-bottom: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
        h1 {
            margin-bottom: 20px;
            font-size: 24px;
        }
        /* キャンバスの幅と高さを固定ピクセル値で指定 */
        #inputStrengthCanvas {
            width: 350px;
            height: 50px;
        }
        #frequencyCanvas {
            width: 350px;
            height: 400px;
        }
    </style>
</head>
<body>
    <h1>Fourier Tone Analyzer</h1>
    <button id="startRecording">録音開始</button>
    <canvas id="inputStrengthCanvas"></canvas>
    <canvas id="frequencyCanvas"></canvas>
    <!-- 録音終了時刻を表示する要素を追加 -->
    <div id="recordingEndTime"></div>

    <script>
        const startButton = document.getElementById('startRecording');
        const inputCanvas = document.getElementById('inputStrengthCanvas');
        const inputCanvasContext = inputCanvas.getContext('2d');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const frequencyCanvasContext = frequencyCanvas.getContext('2d');
        const recordingEndTimeDiv = document.getElementById('recordingEndTime');

        // 縦軸と横軸のラベルを描画する関数
        function drawAxisLabels() {
            const rows = 12; // 12音階
            const cols = 9 + 1; // オクターブ数 + OALL列

            const barWidth = (frequencyCanvas.width - 60) / cols;
            const barHeightUnit = (frequencyCanvas.height - 40) / rows;

            // キャンバスをクリア
            frequencyCanvasContext.clearRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);

            // 縦軸ラベル（音階）を描画
            frequencyCanvasContext.font = '14px Noto Sans JP';
            frequencyCanvasContext.fillStyle = '#595959';
            frequencyCanvasContext.textBaseline = 'middle';
            for (let row = 0; row < rows; row++) {
                frequencyCanvasContext.fillText(
                    ['B', 'A#', 'A', 'G#', 'G', 'F#', 'F', 'E', 'D#', 'D', 'C#', 'C'][row],
                    10,
                    row * barHeightUnit + barHeightUnit / 2 + 20
                );
            }

            // 横軸ラベル（オクターブ）を描画
            frequencyCanvasContext.font = '10px Noto Sans JP';
            frequencyCanvasContext.textAlign = 'center';
            frequencyCanvasContext.fillText('OALL', barWidth / 2 + 40, frequencyCanvas.height - 10);
            for (let col = 1; col < cols; col++) {
                frequencyCanvasContext.fillText(`O${9 - col + 1}`, col * barWidth + barWidth / 2 + 40, frequencyCanvas.height - 10);
            }
        }

        // キャンバスのサイズを設定
        function resizeCanvases() {
            inputCanvas.width = 300;
            inputCanvas.height = 100;
            frequencyCanvas.width = 350;
            frequencyCanvas.height = 400;
            drawAxisLabels(); // ページロード時にラベルを表示
        }
        resizeCanvases();

        let audioContext;
        let analyser;
        let microphone;
        let frequencyData;
        let timeDomainData;
        let mediaStream;
        let isRecording = false;

        // 音階とオクターブの定義
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']; // Cが低い音、Bが高い音
        const octaves = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; // 高いオクターブが左

        // 音階に対応する色
        const noteColors = {
            'C': '#E57373',    // レッド
            'C#': '#FF8A65',   // コーラル
            'D': '#FFB74D',    // オレンジ
            'D#': '#FFD54F',   // ゴールド
            'E': '#FFF176',    // イエロー
            'F': '#AED581',    // ライムグリーン
            'F#': '#81C784',   // グリーン
            'G': '#4DD0E1',    // アクア
            'G#': '#4FC3F7',   // ブルー
            'A': '#7986CB',    // ネイビー
            'A#': '#BA68C8',   // バイオレット
            'B': '#F06292'     // マゼンタ
        };

        // 各オクターブと音階の周波数と色を計算
        const frequencies = [];
        octaves.forEach(octave => {
            notes.forEach((note) => {
                const noteIndex = notes.indexOf(note);
                const frequency = 16.35 * Math.pow(2, octave + noteIndex / 12);
                const color = noteColors[note];
                frequencies.push({ note: note + octave, frequency: frequency, color: color, baseNote: note });
            });
        });

        let recordingDuration = 10; // 録音時間（秒）

        startButton.addEventListener('click', function() {
            if (isRecording) return;
            isRecording = true;
            startButton.disabled = true;
            startButton.textContent = 'マイクにアクセス中...';
        
            // 録音開始時にグラフと録音終了時刻をクリアしてラベルのみを表示
            drawAxisLabels();
            recordingEndTimeDiv.textContent = ''; // 録音終了時刻をクリア
        
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
        
                    frequencyData = new Float32Array(analyser.frequencyBinCount);
                    timeDomainData = new Uint8Array(analyser.fftSize);
                    mediaStream = stream;
        
                    let remainingTime = recordingDuration;
                    startButton.textContent = `録音中... 残り ${remainingTime} 秒`;
        
                    const countdownInterval = setInterval(function() {
                        remainingTime -= 1;
                        if (remainingTime >= 0) {
                            startButton.textContent = `録音中... 残り ${remainingTime} 秒`;
                        }
                    }, 1000);
        
                    // 入力波形をリアルタイムで表示
                    const inputStrengthInterval = setInterval(function() {
                        analyser.getByteTimeDomainData(timeDomainData);
                        drawInputStrength(timeDomainData);
                    }, 30);
        
                    setTimeout(function() {
                        clearInterval(inputStrengthInterval);
                        clearInterval(countdownInterval);
                        startButton.textContent = `録音完了`;
                        analyser.getFloatFrequencyData(frequencyData);
                        const strengths = calculateNoteStrengths(frequencyData);
                        drawNoteStrengths(strengths);
                        displayRecordingEndTime(); // 録音終了時刻を表示
                        stopRecording();
                    }, recordingDuration * 1000);
                })
                .catch(function(err) {
                    console.error("マイクのアクセスに失敗しました: " + err);
                    isRecording = false;
                    startButton.disabled = false;
                    startButton.textContent = "録音開始";
                });
        });

        function stopRecording() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            isRecording = false;
            startButton.disabled = false;
            startButton.textContent = "録音開始";
        }

        // 音声入力の波形をリアルタイムで表示
        function drawInputStrength(timeDomainData) {
            inputCanvasContext.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCanvasContext.lineWidth = 2;
            inputCanvasContext.strokeStyle = 'rgb(0, 102, 204)';
            inputCanvasContext.beginPath();

            const sliceWidth = inputCanvas.width / timeDomainData.length;
            let x = 0;

            for (let i = 0; i < timeDomainData.length; i++) {
                const v = timeDomainData[i] / 128.0;
                const y = v * inputCanvas.height / 2;

                if (i === 0) {
                    inputCanvasContext.moveTo(x, y);
                } else {
                    inputCanvasContext.lineTo(x, y);
                }

                x += sliceWidth;
            }

            inputCanvasContext.lineTo(inputCanvas.width, inputCanvas.height / 2);
            inputCanvasContext.stroke();
        }

        // 各音階の強度を計算
        function calculateNoteStrengths(frequencyData) {
            const sampleRate = audioContext.sampleRate;
            const nyquist = sampleRate / 2;
            const binSize = nyquist / frequencyData.length;
            const strengths = frequencies.map(f => {
                const targetFrequency = f.frequency;
                const index = Math.round(targetFrequency / binSize);
                const decibel = frequencyData[index] || -Infinity;
                return {
                    note: f.note,
                    baseNote: f.baseNote,
                    strength: decibel,
                    color: f.color
                };
            });

            // 各音階ごとに全オクターブの強度を合計
            const totalStrengths = notes.map(note => {
                const noteStrengths = strengths.filter(s => s.baseNote === note).map(s => s.strength);
                const totalStrength = noteStrengths.reduce((a, b) => a + Math.pow(10, b / 10), 0); // パワー（線形値）で合計
                const avgDecibel = 10 * Math.log10(totalStrength); // 合計パワーをデシベル値に変換
                return {
                    note: note,
                    strength: avgDecibel,
                    color: noteColors[note]
                };
            });

            return { strengths, totalStrengths };
        }

        // 音階の強度をグラフで表示
        function drawNoteStrengths({ strengths, totalStrengths }) {
            const rows = 12; // 12音階
            const cols = octaves.length + 1; // オクターブ数 + 1 (OALL列)

            const barWidth = (frequencyCanvas.width - 60) / cols;
            const barHeightUnit = (frequencyCanvas.height - 40) / rows;

            // 縦軸ラベルと横軸ラベルを再描画
            drawAxisLabels();

            const minDb = -140;
            const maxDb = -30;

            // 棒グラフを描画
            for (let row = 0; row < rows; row++) {
                const note = notes[11 - row]; // 上が高い音
                // OALL列
                const totalStrength = totalStrengths.find(s => s.note === note);
                const normalizedTotalStrength = (totalStrength.strength - minDb) / (maxDb - minDb);
                const clampedTotalStrength = Math.max(0, Math.min(1, normalizedTotalStrength));
                const totalHeight = clampedTotalStrength * barHeightUnit;
                const xTotal = 40;
                const y = row * barHeightUnit + 20;

                frequencyCanvasContext.fillStyle = totalStrength.color;
                frequencyCanvasContext.fillRect(
                    xTotal,
                    y + (barHeightUnit - totalHeight),
                    barWidth - 2,
                    totalHeight
                );

                // 数字のラベルを棒の内側、下側に描画
                frequencyCanvasContext.font = '8px Noto Sans JP'; // フォントサイズを小さく設定
                frequencyCanvasContext.fillStyle = '#595959';
                frequencyCanvasContext.fillText(
                    totalStrength.strength.toFixed(1),
                    xTotal + (barWidth - 2) / 2,
                    y + barHeightUnit - 5 // 下側に配置
                );

                // 各オクターブ列
                for (let col = 1; col < cols; col++) {
                    const octave = octaves[col - 1];
                    const noteStrength = strengths.find(s => s.note === note + octave);
                    const normalizedStrength = (noteStrength.strength - minDb) / (maxDb - minDb);
                    const clampedStrength = Math.max(0, Math.min(1, normalizedStrength));
                    const height = clampedStrength * barHeightUnit;
                    const x = col * barWidth + 40;

                    frequencyCanvasContext.fillStyle = noteStrength.color;
                    frequencyCanvasContext.fillRect(
                        x,
                        y + (barHeightUnit - height),
                        barWidth - 2,
                        height
                    );

                    // 数字のラベルを棒の内側、下側に描画
                    frequencyCanvasContext.font = '8px Noto Sans JP'; // フォントサイズを小さく設定
                    frequencyCanvasContext.fillStyle = '#595959';
                    frequencyCanvasContext.fillText(
                        noteStrength.strength.toFixed(1),
                        x + (barWidth - 2) / 2,
                        y + barHeightUnit - 5 // 下側に配置
                    );
                }
            }
        }

        // 録音終了時刻を表示
        function displayRecordingEndTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = ('0' + (now.getMonth() + 1)).slice(-2);
            const day = ('0' + now.getDate()).slice(-2);
            const hours = ('0' + now.getHours()).slice(-2);
            const minutes = ('0' + now.getMinutes()).slice(-2);
            const seconds = ('0' + now.getSeconds()).slice(-2); // 秒数を取得して2桁にフォーマット
            const formattedTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; // 秒数を含めたフォーマット
            recordingEndTimeDiv.style.color = '#999999'; // テキスト色をグレーに設定
            recordingEndTimeDiv.style.fontSize = '12px'; // フォントサイズを小さく設定
            recordingEndTimeDiv.textContent = `recorded at (${formattedTime})`;
        }
    </script>
</body>
</html>
