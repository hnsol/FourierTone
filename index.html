<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Fourier Tone Analyzer</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0;
        }
        canvas {
            border: 1px solid black;
            margin-bottom: 20px;
            margin-left: 10px;
            margin-right: 10px;
        }
        button {
            margin-bottom: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
        h1 {
            margin-bottom: 20px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <h1>Fourier Tone Analyzer</h1>
    <button id="startRecording">録音開始</button>
    <canvas id="inputStrengthCanvas" width="300" height="100"></canvas>
    <canvas id="frequencyCanvas" width="350" height="450"></canvas>

    <script>
        const startButton = document.getElementById('startRecording');
        const inputCanvas = document.getElementById('inputStrengthCanvas');
        const inputCanvasContext = inputCanvas.getContext('2d');
        const frequencyCanvas = document.getElementById('frequencyCanvas');
        const frequencyCanvasContext = frequencyCanvas.getContext('2d');

        // キャンバスのサイズを設定
        function resizeCanvases() {
            inputCanvas.width = inputCanvas.clientWidth;
            inputCanvas.height = inputCanvas.clientHeight;
            frequencyCanvas.width = frequencyCanvas.clientWidth;
            frequencyCanvas.height = frequencyCanvas.clientHeight;
        }
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        let audioContext;
        let analyser;
        let microphone;
        let frequencyData;
        let timeDomainData;
        let mediaStream;
        let isRecording = false;

        // 音階とオクターブ
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']; // Cが低い音、Bが高い音
        const octaves = [7, 6, 5, 4, 3, 2, 1, 0]; // 高いオクターブが左

        // 音階に対応する色
        const noteColors = {
            'C': '#E57373',    // レッド
            'C#': '#FF8A65',   // コーラル
            'D': '#FFB74D',    // オレンジ
            'D#': '#FFD54F',   // ゴールド
            'E': '#FFF176',    // イエロー
            'F': '#AED581',    // ライムグリーン
            'F#': '#81C784',   // グリーン
            'G': '#4DD0E1',    // アクア
            'G#': '#4FC3F7',   // ブルー
            'A': '#7986CB',    // ネイビー
            'A#': '#BA68C8',   // バイオレット
            'B': '#F06292'     // マゼンタ
        };

        // 各オクターブと音階の周波数と色
        const frequencies = [];
        octaves.forEach(octave => {
            notes.forEach((note) => {
                const frequency = 16.35 * Math.pow(2, octave + notes.indexOf(note) / 12);
                const color = noteColors[note]; // 音階名のみで色を取得
                frequencies.push({ note: note + octave, frequency: frequency, color: color });
            });
        });

        let recordingDuration = 5; // 録音時間（秒）

        startButton.addEventListener('click', function() {
            if (isRecording) return;
            isRecording = true;
            startButton.disabled = true;
            startButton.textContent = 'マイクにアクセス中...';

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 2048;
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);

                    frequencyData = new Float32Array(analyser.frequencyBinCount);
                    timeDomainData = new Uint8Array(analyser.fftSize);
                    mediaStream = stream;

                    let remainingTime = recordingDuration;
                    startButton.textContent = `録音中... 残り ${remainingTime} 秒`;

                    const countdownInterval = setInterval(function() {
                        remainingTime -= 1;
                        if (remainingTime >= 0) {
                            startButton.textContent = `録音中... 残り ${remainingTime} 秒`;
                        }
                    }, 1000);

                    // 入力波形をリアルタイムで表示
                    const inputStrengthInterval = setInterval(function() {
                        analyser.getByteTimeDomainData(timeDomainData);
                        drawInputStrength(timeDomainData);
                    }, 30);

                    setTimeout(function() {
                        clearInterval(inputStrengthInterval);
                        clearInterval(countdownInterval);
                        startButton.textContent = `録音完了`;
                        analyser.getFloatFrequencyData(frequencyData);
                        const strengths = calculateNoteStrengths(frequencyData);
                        drawNoteStrengths(strengths);
                        stopRecording();
                    }, recordingDuration * 1000);
                })
                .catch(function(err) {
                    console.error("マイクのアクセスに失敗しました: " + err);
                    isRecording = false;
                    startButton.disabled = false;
                    startButton.textContent = "録音開始";
                });
        });

        function stopRecording() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
            isRecording = false;
            startButton.disabled = false;
            startButton.textContent = "録音開始";
        }

        // 音声入力の波形をリアルタイムで表示
        function drawInputStrength(timeDomainData) {
            inputCanvasContext.clearRect(0, 0, inputCanvas.width, inputCanvas.height);
            inputCanvasContext.lineWidth = 2;
            inputCanvasContext.strokeStyle = 'rgb(0, 102, 204)';
            inputCanvasContext.beginPath();

            const sliceWidth = inputCanvas.width / timeDomainData.length;
            let x = 0;

            for (let i = 0; i < timeDomainData.length; i++) {
                const v = timeDomainData[i] / 128.0;
                const y = v * inputCanvas.height / 2;

                if (i === 0) {
                    inputCanvasContext.moveTo(x, y);
                } else {
                    inputCanvasContext.lineTo(x, y);
                }

                x += sliceWidth;
            }

            inputCanvasContext.lineTo(inputCanvas.width, inputCanvas.height / 2);
            inputCanvasContext.stroke();
        }

        // 各音階の強度を計算
        function calculateNoteStrengths(frequencyData) {
            const sampleRate = audioContext.sampleRate;
            const nyquist = sampleRate / 2;
            const binSize = nyquist / analyser.frequencyBinCount;
            const strengths = frequencies.map(f => {
                const targetFrequency = f.frequency;
                const index = Math.round(targetFrequency / binSize);
                const decibel = frequencyData[index] || -Infinity;
                return {
                    note: f.note,
                    strength: decibel,
                    color: f.color
                };
            });
            return strengths;
        }

        // 音階の強度をグラフで表示
        function drawNoteStrengths(strengths) {
            const rows = 12; // 12音階
            const cols = 8;  // 8オクターブ

            const barWidth = (frequencyCanvas.width - 60) / cols;
            const barHeightUnit = (frequencyCanvas.height - 40) / rows;

            // キャンバスをクリア
            frequencyCanvasContext.clearRect(0, 0, frequencyCanvas.width, frequencyCanvas.height);

            // フォント設定
            frequencyCanvasContext.font = '14px Arial';
            frequencyCanvasContext.textBaseline = 'middle';

            // 縦軸（音階ラベル）を描画（上が高い音）
            for (let row = 0; row < rows; row++) {
                frequencyCanvasContext.fillStyle = 'black';
                frequencyCanvasContext.fillText(
                    notes[11 - row],
                    10,
                    row * barHeightUnit + barHeightUnit / 2 + 20
                );
            }

            // 横軸（オクターブラベル）を描画（左が高いオクターブ）
            for (let col = 0; col < cols; col++) {
                frequencyCanvasContext.fillStyle = 'black';
                frequencyCanvasContext.textAlign = 'center';
                frequencyCanvasContext.fillText(
                    'O' + octaves[col],
                    col * barWidth + barWidth / 2 + 40,
                    frequencyCanvas.height - 10
                );
            }

            const minDb = -100;
            const maxDb = -30;

            // 棒グラフを描画
            for (let col = 0; col < cols; col++) {
                for (let row = 0; row < rows; row++) {
                    const i = col * rows + (rows - 1 - row); // インデックス修正
                    const strength = strengths[i];
                    const x = col * barWidth + 40;
                    const y = row * barHeightUnit + 20;

                    const normalizedStrength = (strength.strength - minDb) / (maxDb - minDb);
                    const clampedStrength = Math.max(0, Math.min(1, normalizedStrength));

                    const height = clampedStrength * barHeightUnit;

                    frequencyCanvasContext.fillStyle = strength.color;
                    frequencyCanvasContext.fillRect(
                        x,
                        y + (barHeightUnit - height),
                        barWidth - 2,
                        height
                    );
                }
            }
        }
    </script>
</body>
</html>
